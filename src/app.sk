@import
namespace Date {
    def now int
}

@import
namespace console {
    const log dynamic
}

class GameOfLife {
    var _canvas HTMLCanvasElement
    var _igloo Igloo
    var _timer Box<Interval>
    var _programs StringMap<Igloo.Program>
    var _buffers StringMap<Igloo.Buffer>
    var _textures StringMap<Igloo.Texture>
    var _framebuffers StringMap<Igloo.FrameBuffer>

    # Always a 2d array of <canvas /> [width, height]
    var _viewSize Float32Array

    # Always a 2d array of simulation grid [width, height]
    var _stateSize Float32Array

    def new(canvas HTMLCanvasElement, scale int) {
        _canvas = canvas
        _igloo = Igloo.new(canvas)
        console.log(_igloo.defaultFramebuffer)
        if _igloo.gl == null {
            throw "Bah!"
        }

        _viewSize = Float32Array.new([_canvas.width, _canvas.height])
        _stateSize = Float32Array.new([_canvas.width / scale, _canvas.height / scale])
        _timer = null

        var gl = _igloo.gl
        gl.disable(gl.DEPTH_TEST)

        _programs = {
            "copy": _igloo.program("glsl/quad.vert", "glsl/copy.frag"),
            "gol": _igloo.program("glsl/quad.vert", "glsl/gol.frag")
        }

        _buffers = {
            "quad": _igloo.array(Igloo.QUAD2)
        }

        _textures = {
            "front": _igloo.texture(null, gl.RGBA, gl.REPEAT, gl.NEAREST).blank(_stateSize[0] as int, _stateSize[1] as int),
            "back": _igloo.texture(null, gl.RGBA, gl.REPEAT, gl.NEAREST).blank(_stateSize[0] as int, _stateSize[1] as int)
        }

        _framebuffers = {
            "step": _igloo.framebuffer
        }

        setRandom
    }

    def set(state Uint8Array) GameOfLife {
        var rgba = Uint8Array.new((_stateSize[0] * _stateSize[1] * 4) as int)
        for i in 0..state.length {
            var j = i * 4
            rgba[j + 0] = state[i] == 1 ? 255 : 0
            rgba[j + 1] = state[i] == 1 ? 255 : 0
            rgba[j + 2] = state[i] == 1 ? 255 : 0
            rgba[j + 3] = 255
        }
        _textures["front"].subset(rgba, 0, 0, _stateSize[0] as int, _stateSize[1] as int)
        return self
    }

    def setRandom {
        const rand = Uint8Array.new((_stateSize[0] * _stateSize[1]) as int)
        for i in 0..rand.length {
            rand[i] = Math.random < 0.5 ? 1 : 0
        }
        set(rand)
    }

    def setEmpty {
        set(Uint8Array.new((_stateSize[0] * _stateSize[1]) as int))
    }

    def swap {
        const tmp = _textures["front"]
        _textures["front"] = _textures["back"]
        _textures["back"] = tmp
    }

    def step {
        const gl = _igloo.gl
        _framebuffers["step"].attach(_textures["back"])
        _textures["front"].bind(0)
        gl.viewport(0, 0, _stateSize[0] as int, _stateSize[1] as int)
        _programs["gol"]
            .use
            .attrib("quad", _buffers["quad"], 2)
            .uniformi("state", 0)
            .uniform("scale", _stateSize)
            .draw(gl.TRIANGLE_STRIP, 4)
        swap
    }

    def draw {
        const gl = _igloo.gl
        _igloo.defaultFramebuffer.bind
        _textures["front"].bind(0)
        gl.viewport(0, 0, _viewSize[0] as int, _viewSize[1] as int)
        _programs["copy"]
            .use
            .attrib("quad", _buffers["quad"], 2)
            .uniformi("state", 0)
            .uniform("scale", _viewSize)
            .draw(gl.TRIANGLE_STRIP, 4)
    }

    def poke(x int, y int, state bool) {
        const v = state ? 255 : 0
        _textures["front"].subset([v, v, v, 255], x, y, 1, 1)
    }

    def get Uint8Array {
        const gl = _igloo.gl
        const w = _stateSize[0] as int
        const h = _stateSize[1] as int
        _framebuffers["step"].attach(_textures["front"])
        const rgba = Uint8Array.new(w * h * 4)
        gl.readPixels(0, 0, w, h, gl.RGBA, gl.UNSIGNED_BYTE, rgba)
        const state = Uint8Array.new(w * h)
        for i in 0..w * h {
            state[i] = rgba[i * 4] > 128 ? 1 : 0
        }
        return state
    }

    def start {
        if _timer == null {
            _timer = Box<Interval>.new(setInterval(() => {
                step
                draw
            }, 60))
        }
    }

    def stop {
        clearInterval(_timer.value)
        _timer = null
    }

    def toggle {
        if _timer == null {
            start
        } else {
            stop
        }
    }

    def eventCoord {
        # TODO(ryan)
    }
}


class HTMLWindow {
    var onload dynamic
    var onresize dynamic
}

@entry
def main {
    window.onload = => {
        const canvas = document.getElementById("gol-canvas") as HTMLCanvasElement
        const gol = GameOfLife.new(canvas, 4)
        gol.draw
        gol.start
    }
}


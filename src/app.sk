
@import
class Igloo {
    var gl WebGLRenderingContext
    var defaultFramebuffer Igloo.FrameBuffer

    def new(canvas HTMLElement)
    def program(vert string, frag string) Igloo.Program
    def array(arr Float32Array) Igloo.Buffer
    def texture(source dynamic, format GLenum, wrap GLenum, filter GLenum) Igloo.Texture
    def framebuffer Igloo.FrameBuffer
}

namespace Igloo {
    const QUAD2 Float32Array
}

class Igloo.Program {
    def use Program
    def attrib(name string, value dynamic, size int) Program
    def uniformi(name string, value int) Program
    def uniform(name string, value dynamic) Program
    def draw(mode GLenum, count int) Program
}

class Igloo.FrameBuffer {
    def attach(texture Texture) FrameBuffer
    def bind
}

class Igloo.Texture {
    def blank(width int, height int) Igloo.Texture
    def subset(source dynamic, xoff int, yoff int, width int, height int)
    def bind(unit int) Texture
}

class Igloo.Buffer {

}

@import
namespace Date {
    def now int
}

@import
namespace console {
    const log dynamic
}

def timeInSeconds double {
    return Math.floor(Date.now / 1000)
}

class GameOfLife {
    var canvas HTMLCanvasElement
    var igloo Igloo
    var timer Box<Interval>
    var lastTick double = -1
    var fps int
    var programs StringMap<Igloo.Program>
    var buffers StringMap<Igloo.Buffer>
    var textures StringMap<Igloo.Texture>
    var framebuffers StringMap<Igloo.FrameBuffer>

    var viewSize Float32Array
    var stateSize Float32Array

    def new(canvas_ HTMLCanvasElement, scale int) {
        canvas = canvas_
        igloo = Igloo.new(canvas_)
        console.log(igloo.defaultFramebuffer)
        if igloo.gl == null {
            throw "Bah!"
        }
        if scale < 0 {
            scale = 1
        }

        # TODO(ryan): Shouldn't have to set this explicitly
        canvas.width = 1024
        canvas.height = 512

        viewSize = Float32Array.new([canvas.width, canvas.height])
        stateSize = Float32Array.new([canvas.width / scale, canvas.height / scale])
        timer = null
        lastTick = timeInSeconds
        fps = 0

        var gl = igloo.gl
        gl.disable(gl.DEPTH_TEST)

        programs = {
            "copy": igloo.program("glsl/quad.vert", "glsl/copy.frag"),
            "gol": igloo.program("glsl/quad.vert", "glsl/gol.frag")
        }

        buffers = {
            "quad": igloo.array(Igloo.QUAD2)
        }

        textures = {
            "front": igloo.texture(null, gl.RGBA, gl.REPEAT, gl.NEAREST).blank(stateSize[0] as int, stateSize[1] as int),
            "back": igloo.texture(null, gl.RGBA, gl.REPEAT, gl.NEAREST).blank(stateSize[0] as int, stateSize[1] as int)
        }

        framebuffers = {
            "step": igloo.framebuffer
        }

        setRandom
    }

    def set(state Uint8Array) GameOfLife {
        var rgba = Uint8Array.new((stateSize[0] * stateSize[1] * 4) as int)
        for i in 0..state.length {
            var j = i * 4
            rgba[j + 0] = state[i] == 1 ? 255 : 0
            rgba[j + 1] = state[i] == 1 ? 255 : 0
            rgba[j + 2] = state[i] == 1 ? 255 : 0
            rgba[j + 3] = 255
        }
        textures["front"].subset(rgba, 0, 0, stateSize[0] as int, stateSize[1] as int)
        return self
    }

    def setRandom {
        const rand = Uint8Array.new((stateSize[0] * stateSize[1]) as int)
        for i in 0..rand.length {
            rand[i] = Math.random < 0.5 ? 1 : 0
        }
        set(rand)
    }

    def setEmpty {
        set(Uint8Array.new((stateSize[0] * stateSize[1]) as int))
    }

    def swap {
        const tmp = textures["front"]
        textures["front"] = textures["back"]
        textures["back"] = tmp
    }

    def step {
        # TODO(ryan): can do better than this to calculate fps
        if timeInSeconds != lastTick {
            lastTick = timeInSeconds
            fps = 0
        } else {
            fps += 1
        }

        const gl = igloo.gl
        framebuffers["step"].attach(textures["back"])
        textures["front"].bind(0)
        gl.viewport(0, 0, stateSize[0] as int, stateSize[1] as int)
        programs["gol"]
            .use
            .attrib("quad", buffers["quad"], 2)
            .uniformi("state", 0)
            .uniform("scale", stateSize)
            .draw(gl.TRIANGLE_STRIP, 4)
        swap
    }

    def draw {
        const gl = igloo.gl
        igloo.defaultFramebuffer.bind
        textures["front"].bind(0)
        gl.viewport(0, 0, viewSize[0] as int, viewSize[1] as int)
        programs["copy"]
            .use
            .attrib("quad", buffers["quad"], 2)
            .uniformi("state", 0)
            .uniform("scale", viewSize)
            .draw(gl.TRIANGLE_STRIP, 4)
    }

    def poke(x int, y int, state bool) {
        const v = state ? 255 : 0
        textures["front"].subset([v, v, v, 255], x, y, 1, 1)
    }

    def get Uint8Array {
        const gl = igloo.gl
        const w = stateSize[0] as int
        const h = stateSize[1] as int
        framebuffers["step"].attach(textures["front"])
        const rgba = Uint8Array.new(w * h * 4)
        gl.readPixels(0, 0, w, h, gl.RGBA, gl.UNSIGNED_BYTE, rgba)
        const state = Uint8Array.new(w * h)
        for i in 0..w * h {
            state[i] = rgba[i * 4] > 128 ? 1 : 0
        }
        return state
    }

    def start {
        if timer == null {
            timer = Box<Interval>.new(setInterval(() => {
                step
                draw
            }, 60))
        }
    }

    def stop {
        clearInterval(timer.value)
        timer = null
    }

    def toggle {
        if timer == null {
            start
        } else {
            stop
        }
    }

    def eventCoord {
        # TODO(ryan)
    }
}


class HTMLWindow {
    var onload dynamic
    var onresize dynamic
}

@entry
def main {
    window.onload = => {
        const canvas = document.getElementById("gol-canvas") as HTMLCanvasElement
        const gol = GameOfLife.new(canvas, 1)
        gol.draw
        gol.start
    }
}

